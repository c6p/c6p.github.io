<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="History #  Just Libraries #  OS would provide API. Jobs set up and then run in a batch by the operator. Computers were not interactive.
Protection #  The idea of system call invented by Atlas computing system. Instead of providing OS routines as a library (procedure call), special instructions to transition into a more formal, controlled process.
 mermaid.initialize({ &#34;flowchart&#34;: { &#34;useMaxWidth&#34;:true }, &#34;theme&#34;: &#34;dark&#34; } ) sequenceDiagram participant U as User Mode participant K as Kernel Mode U-K: trap K-U: return-from-trap Multiprogramming #  I/O devices were slow, having a program wait CPU was a waste of time."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="History #  Just Libraries #  OS would provide API. Jobs set up and then run in a batch by the operator. Computers were not interactive.
Protection #  The idea of system call invented by Atlas computing system. Instead of providing OS routines as a library (procedure call), special instructions to transition into a more formal, controlled process.
 mermaid.initialize({ &#34;flowchart&#34;: { &#34;useMaxWidth&#34;:true }, &#34;theme&#34;: &#34;dark&#34; } ) sequenceDiagram participant U as User Mode participant K as Kernel Mode U-K: trap K-U: return-from-trap Multiprogramming #  I/O devices were slow, having a program wait CPU was a waste of time."><meta property="og:type" content="article"><meta property="og:url" content="https://c6p.github.io/docs/ossu/operating_systems/"><title>Operating Systems | c6p - log</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.fb083b098da3f70a9a4bf04417ff939fdc608d919e8557b0e4d4e517d35a14e4.css integrity="sha256-+wg7CY2j9wqaS/BEF/+Tn9xgjZGehVew5NTlF9NaFOQ="><script defer src=/en.search.min.fe60d29989a28e7366641d3442bafa61208fbe34ce037ae0f0a061999c028db6.js integrity="sha256-/mDSmYmijnNmZB00Qrr6YSCPvjTOA3rg8KBhmZwCjbY="></script><base rel="noopener noreferrer"><script defer src=https://c6p.github.io/vendor.min.545fa4681a2123c00c7be917d08c166f323e008da6d8fd5367f95c014997efd0.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre'],renderActions:{addMenu:[]}}};window.onload=(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>c6p - log</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/posts/>Blog</a></li></ul><hr><ul><li><a href=https://c6p.github.io/docs/learning/exercism/>Exercism</a></li><li><a href=https://c6p.github.io/docs/learning/resources/>Resources</a></li><li><a href=https://c6p.github.io/docs/ossu/operating_systems/ class=active>Operating Systems</a></li></ul><hr></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Operating Systems</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#history>History</a><ul><li><a href=#just-libraries>Just Libraries</a></li><li><a href=#protection>Protection</a></li><li><a href=#multiprogramming>Multiprogramming</a></li><li><a href=#modern-era>Modern Era</a></li></ul></li><li><a href=#the-process>The Process</a><ul><li><a href=#process-states>Process States</a></li><li><a href=#process-api>Process API</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=history>History
<a class=anchor href=#history>#</a></h2><h3 id=just-libraries>Just Libraries
<a class=anchor href=#just-libraries>#</a></h3><p>OS would provide API. Jobs set up and then run in a <code>batch</code> by the operator. Computers were not interactive.</p><h3 id=protection>Protection
<a class=anchor href=#protection>#</a></h3><p>The idea of <code>system call</code> invented by Atlas computing system. Instead of providing OS routines as a library (<code>procedure call</code>), special instructions to transition into a more formal, controlled process.</p><script src=/mermaid.min.js></script><script>mermaid.initialize({"flowchart":{"useMaxWidth":true},"theme":"dark"})</script><p class=mermaid>sequenceDiagram
participant U as User Mode
participant K as Kernel Mode
U->>K: trap
K->>U: return-from-trap</p><h3 id=multiprogramming>Multiprogramming
<a class=anchor href=#multiprogramming>#</a></h3><p>I/O devices were slow, having a program wait CPU was a waste of time. Memory protection and concurrency became critical in the presence of I/O and interrupts. Unix was introduced inspired by TENEX and Berkeley Time-Sharing System.</p><h3 id=modern-era>Modern Era
<a class=anchor href=#modern-era>#</a></h3><p>DOS didn’t think memory protection was important; thus, a malicious application could scribble all over memory. Mac OS(v9 and earlier) took a cooperative approach to job scheduling; thus, a thread that accidentally got stuck in an infinite loop could take over the entire system, forcing a reboot.</p><h2 id=the-process>The Process
<a class=anchor href=#the-process>#</a></h2><p><strong>Time sharing</strong> allows OS to share CPU resource, by <strong>context-switch</strong> (stop a program to run another). A <strong>scheduling policy</strong> let OS to decide which program to run.</p><p><strong>Address space</strong> is the memory the process can address, registers are also part of process&rsquo;s machine state. For example <strong>program counter (PC, or instruction pointer IP)</strong> tells which instruction to execute next, <strong>stack pointer</strong> and associated <strong>frame pointer</strong> are used to manage the stack for function parameters, local variables and return addresses.
<img src=../../../../attachments/2021-04-28-12-29-07_program_to_process.png alt></p><p>In early OSes loading done eagerly, modern OSes perform it lazily by <strong>paging</strong> and <strong>swapping</strong>.</p><h3 id=process-states>Process States
<a class=anchor href=#process-states>#</a></h3><p><p class=mermaid>stateDiagram-v2
Running --> Ready : Descheduled
Ready --> Running : Scheduled
Running --> Blocked : I/O initiate
Blocked --> Ready : I/O done</p><strong>Running</strong>: executing instructions<br><strong>Ready</strong>: ready, but OS has chosen not to run<br><strong>Blocked</strong>: not ready. I/O request etc.<br>These decisions are made by OS <strong>scheduler</strong>.</p><table><thead><tr><th>Time</th><th>Process$_0$</th><th>Process$_1$</th><th>Notes</th></tr></thead><tbody><tr><td>1</td><td>Running</td><td>Ready</td><td></td></tr><tr><td>2</td><td>Running</td><td>Ready</td><td></td></tr><tr><td>3</td><td>Running</td><td>Ready</td><td>Process$_0$ initiates I/O</td></tr><tr><td>4</td><td>Blocked</td><td>Running</td><td>Process$_0$ is blocked,</td></tr><tr><td>5</td><td>Blocked</td><td>Running</td><td>so Process$_1$ runs</td></tr><tr><td>6</td><td>Blocked</td><td>Running</td><td></td></tr><tr><td>7</td><td>Ready</td><td>Running</td><td>I/O done</td></tr><tr><td>8</td><td>Ready</td><td>Running</td><td>Process$_1$ now done</td></tr><tr><td>9</td><td>Running</td><td>–</td><td></td></tr><tr><td>10</td><td>Running</td><td>–</td><td>Process$_0$ now done</td></tr></tbody></table><h3 id=process-api>Process API
<a class=anchor href=#process-api>#</a></h3><p><strong>Shell</strong> run code after the call to <code>fork()</code> (to create a new child process by copying parent) but before the call to <code>exec()</code> (to run the command); this code can alter the environment of the about-to-be-run program, and then waits for the command to complete by calling <code>wait()</code>. When the child completes, shell returns, ready for next command. This enables features like input/output redirection, pipes.</p><p>Each process has a name, in most systems a number, <strong>process ID (PID)</strong>. Control is available in the form of <strong>signals</strong> to stop, continue, terminate.</p><p>The control is encapsulated by the notion of <strong>user</strong>, whom can only control their own processes. A <strong>superuser</strong> can control all processes.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#history>History</a><ul><li><a href=#just-libraries>Just Libraries</a></li><li><a href=#protection>Protection</a></li><li><a href=#multiprogramming>Multiprogramming</a></li><li><a href=#modern-era>Modern Era</a></li></ul></li><li><a href=#the-process>The Process</a><ul><li><a href=#process-states>Process States</a></li><li><a href=#process-api>Process API</a></li></ul></li></ul></nav></aside></main></body></html>